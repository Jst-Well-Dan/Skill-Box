<!--
本文件由智谱 AI 自动翻译生成
原文件: mcp_best_practices.md
翻译时间: 2025-12-12 16:11:17
翻译模型: glm-4-flash
原文大小: 28,910 字符
-->

# MCP 服务器开发最佳实践和指南

## 概述

本文档汇集了构建模型上下文协议（MCP）服务器的基本最佳实践和指南。它涵盖了命名约定、工具设计、响应格式、分页、错误处理、安全性和合规性要求。

---

## 快速参考

### 服务器命名
- **Python**: `{service}_mcp`（例如，`slack_mcp`）
- **Node/TypeScript**: `{service}-mcp-server`（例如，`slack-mcp-server`）

### 工具命名
- 使用 snake_case 并带有服务前缀
- 格式：`{service}_{action}_{resource}`
- 示例：`slack_send_message`, `github_create_issue`

### 响应格式
- 支持JSON和Markdown格式
- JSON用于程序性处理
- Markdown用于人类可读性

### 分页
- 总是尊重`limit`参数
- 返回`has_more`、`next_offset`、`total_count`
- 默认为20-50项

### 字符限制
- 设置CHARACTER_LIMIT常量（通常为25,000）
- 优雅地截断并给出清晰的提示
- 提供过滤指导

---

## 目录

1. 服务器命名约定
2. 工具命名和设计
3. 响应格式指南
4. 分页最佳实践
5. 字符限制和截断
6. 工具开发最佳实践
7. 传输最佳实践
8. 测试要求
9. OAuth和安全最佳实践
10. 资源管理最佳实践
11. 提示管理最佳实践
12. 错误处理标准
13. 文档要求
14. 合规性和监控

---

## 1. 服务器命名约定

遵循以下标准化的命名模式进行MCP服务器命名：

**Python**: 使用格式 `{service}_mcp`（小写带下划线）
- 示例：`slack_mcp`、`github_mcp`、`jira_mcp`、`stripe_mcp`

**Node/TypeScript**: 使用格式 `{service}-mcp-server`（小写带连字符）
- 示例：`slack-mcp-server`、`github-mcp-server`、`jira-mcp-server`

名称应：
- 通用（不与特定功能相关）
- 描述服务/API的集成
- 易于从任务描述中推断
- 不包含版本号或日期

---

## 2. 工具命名和设计

### 工具命名最佳实践

1. **使用 snake_case**: `search_users`、`create_project`、`get_channel_info`
2. **包含服务前缀**：预计您的MCP服务器可能与其他MCP服务器一起使用
   - 使用 `slack_send_message` 而不是 `send_message`
   - 使用 `github_create_issue` 而不是 `create_issue`
   - 使用 `asana_list_tasks` 而不是 `list_tasks`
3. **以动作为导向**：以动词开头（get、list、search、create 等）
4. **具体明确**：避免与其他服务器冲突的通用名称
5. **保持一致性**：在您的服务器内使用一致的命名模式

### 工具设计指南

- 工具描述必须精确且无歧义地描述功能
- 描述必须与实际功能精确匹配
- 不应与其他MCP服务器造成混淆
- 应提供工具注释（readOnlyHint、destructiveHint、idempotentHint、openWorldHint）
- 保持工具操作集中和原子化

---

## 3. 响应格式指南

所有返回数据的工具应支持多种格式以提高灵活性：

### JSON格式 (`response_format="json"`)
- 机器可读的格式化数据
- 包含所有可用字段和元数据
- 一致的字段名称和类型
- 适用于程序性处理
- 用于LLM需要进一步处理数据的情况

### Markdown格式 (`response_format="markdown"`，通常默认）
- 人类可读的格式化文本
- 使用标题、列表和格式以提高清晰度
- 将时间戳转换为人类可读格式（例如，“2024-01-15 10:30:00 UTC”而不是纪元）
- 显示带有ID的显示名称（例如，“@john.doe (U123456)”）
- 省略冗长的元数据（例如，只显示一个配置文件图片URL，而不是所有大小）
- 合理地组织相关信息
- 用于向用户展示信息的情况

---

## 4. 分页最佳实践

对于列出资源的工具：

- **始终尊重`limit`参数**：当指定限制时，切勿加载所有结果
- **实现分页**：使用`offset`或基于游标的分页
- **返回分页元数据**：包括`has_more`、`next_offset`/`next_cursor`、`total_count`
- **切勿将所有结果加载到内存中**：对于大型数据集尤其重要
- **默认为合理的限制**：20-50项是典型的
- **在响应中包含清晰的分页信息**：使LLM能够请求更多数据

示例分页响应结构：
```json
{
  "total": 150,
  "count": 20,
  "offset": 0,
  "items": [...],
  "has_more": true,
  "next_offset": 20
}
```

---

## 5. 字符限制和截断

为了防止响应中数据过多：

- **定义CHARACTER_LIMIT常量**：通常在模块级别为25,000个字符
- **在返回之前检查响应大小**：测量最终响应长度
- **优雅地截断并给出清晰的提示**：让LLM知道数据已被截断
- **提供过滤指导**：建议如何使用参数来减少结果
- **包含截断元数据**：显示截断的内容以及如何获取更多

示例截断处理：
```python
CHARACTER_LIMIT = 25000

if len(result) > CHARACTER_LIMIT:
    truncated_data = data[:max(1, len(data) // 2)]
    response["truncated"] = True
    response["truncation_message"] = (
        f"响应从 {len(data)} 截断到 {len(truncated_data)} 项。 "
        f"使用 'offset' 参数或添加过滤器以查看更多结果。"
    )
```

---

## 6. 传输选项

MCP服务器支持多种传输机制，适用于不同的部署场景：

### Stdio传输

**最佳用途**：命令行工具、本地集成、子进程执行

**特点**：
- 标准输入/输出流通信
- 简单设置，无需网络配置
- 作为客户端的子进程运行
- 适用于桌面应用程序和CLI工具

**使用情况**：
- 构建用于本地开发环境的工具
- 与桌面应用程序集成（例如，Claude Desktop）
- 创建命令行实用程序
- 单用户、单会话场景

### HTTP传输

**最佳用途**：Web服务、远程访问、多客户端场景

**特点**：
- 通过HTTP的请求-响应模式
- 支持多个并发客户端
- 可作为Web服务部署
- 需要网络配置和安全考虑

**使用情况**：
- 同时服务于多个客户端
- 作为云服务部署
- 与Web应用程序集成
- 需要负载均衡或扩展

### 服务器端事件（SSE）传输

**最佳用途**：实时更新、推送通知、流数据

**特点**：
- 通过HTTP的单一服务器到客户端流
- 使LLM能够在不轮询的情况下接收实时更新
- 长连接以实现连续数据流
- 建立在标准HTTP基础设施之上

**使用情况**：
- 客户端需要实时数据更新
- 实现推送通知
- 流式传输日志或监控数据
- 长操作的结果递进式交付

### 传输选择标准

| 标准 | Stdio | HTTP | SSE |
| ---- | ----- | ---- | --- |
| **部署** | 本地 | 远程 | 远程 |
| **客户端** | 单个 | 多个 | 多个 |
| **通信** | 双向 | 请求-响应 | 服务器-推送 |
| **复杂性** | 低 | 中等 | 中等-高 |
| **实时** | 否 | 否 | 是 |

---

## 7. 工具开发最佳实践

### 一般指南
1. 工具名称应具有描述性和动作导向
2. 使用参数验证并带有详细的JSON模式
3. 在工具描述中包含示例
4. 实现适当的错误处理和验证
5. 对于长时间操作使用进度报告
6. 保持工具操作集中和原子化
7. 记录预期的返回值结构
8. 实现适当的超时
9. 考虑对资源密集型操作进行速率限制
10. 记录工具使用情况以进行调试和监控

### 工具的安全考虑

#### 输入验证
- 验证所有参数与模式
- 清理文件路径和系统命令
- 验证URL和外部标识符
- 检查参数大小和范围
- 防止命令注入

#### 访问控制
- 在需要的地方实现身份验证
- 使用适当的授权检查
- 审计工具使用情况
- 速率限制请求
- 监控滥用

#### 错误处理
- 不要向客户端暴露内部错误
- 在服务器端记录安全相关的错误
- 适当处理超时
- 在错误后清理资源
- 验证返回值