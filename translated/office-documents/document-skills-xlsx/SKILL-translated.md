<!--
本文件由智谱 AI 自动翻译生成
原文件: SKILL.md
翻译时间: 2025-12-12 16:13:25
翻译模型: glm-4-flash
原文大小: 10,628 字符
-->

---
name: xlsx
description: "支持公式、格式、数据分析、可视化的综合电子表格创建、编辑和分析。当Claude需要处理电子表格（.xlsx、.xlsm、.csv、.tsv等）时，用于：(1) 创建带有公式和格式的新的电子表格，(2) 读取或分析数据，(3) 修改现有电子表格同时保留公式，(4) 在电子表格中进行数据分析和可视化，或(5) 重新计算公式"
license: Proprietary. LICENSE.txt has complete terms
---

# 输出要求

## 所有Excel文件

### 零公式错误
- 每个Excel模型必须交付时无任何公式错误（#REF!、#DIV/0!、#VALUE!、#N/A、#NAME?）

### 保留现有模板（当更新模板时）
- 修改文件时，研究和完全匹配现有格式、样式和约定
- 永远不要将标准化格式强加于具有既定模式的文件
- 现有模板约定始终优先于这些指南

## 财务模型

### 颜色编码标准
除非用户或现有模板另有说明

#### 行业标准颜色约定
- **蓝色文本（RGB：0，0，255）**：硬编码的输入，以及用户将更改的情景中的数字
- **黑色文本（RGB：0，0，0）**：所有公式和计算
- **绿色文本（RGB：0，128，0）**：从同一工作簿内的其他工作表拉取的链接
- **红色文本（RGB：255，0，0）**：指向其他文件的链接
- **黄色背景（RGB：255，255，0）**：需要关注的关键假设或需要更新的单元格

### 数字格式化标准

#### 必需的格式规则
- **年份**：格式化为文本字符串（例如，“2024”而不是“2,024”）
- **货币**：使用$#,##0格式；始终在标题中指定单位（“收入（$mm）”）
- **零**：使用数字格式使所有零为“-”，包括百分比（例如，“$#,##0;($#,##0);-”）
- **百分比**：默认为0.0%格式（一位小数）
- **倍数**：格式化为0.0x进行估值倍数（EV/EBITDA、P/E）
- **负数**：使用括号（123）而不是减号-123

### 公式构建规则

#### 假设位置
- 将所有假设（增长率、利润率、倍数等）放置在单独的假设单元格中
- 在公式中使用单元格引用而不是硬编码的值
- 示例：使用=B5*(1+$B$6)而不是=B5*1.05

#### 预防公式错误
- 核实所有单元格引用是否正确
- 检查范围中的偏移量错误
- 确保所有预测期间的公式一致
- 使用边缘情况（零值、负数）进行测试
- 核实没有意外的循环引用

#### 硬编码的文档要求
- 在单元格旁边注释（如果表格末尾）。格式：“来源：[系统/文档]，[日期]，[具体参考]，[如有适用，请提供URL]”
- 示例：
  - “来源：公司10-K，财年2024，第45页，收入注释，[SEC EDGAR URL]”
  - “来源：公司10-Q，2025年第二季度，附件99.1，[SEC EDGAR URL]”
  - “来源：彭博终端，2025年8月15日，AAPL美国股票”
  - “来源：FactSet，2025年8月20日，共识估计屏幕”

# XLSX创建、编辑和分析

## 概述

用户可能要求您创建、编辑或分析.xlsx文件的内容。您有不同工具和工作流程可用于不同的任务。

## 重要要求

**LibreOffice必需用于公式重新计算**：您可以使用`recalc.py`脚本来假设LibreOffice已安装，以重新计算公式值。该脚本在首次运行时自动配置LibreOffice

## 读取和分析数据

### 使用pandas进行数据分析
对于数据分析、可视化和基本操作，请使用**pandas**，它提供了强大的数据处理能力：

```python
import pandas as pd

# 读取Excel
df = pd.read_excel('file.xlsx')  # 默认：第一个工作表
all_sheets = pd.read_excel('file.xlsx', sheet_name=None)  # 所有工作表作为字典

# 分析
df.head()      # 预览数据
df.info()      # 列信息
df.describe()  # 统计

# 写入Excel
df.to_excel('output.xlsx', index=False)
```

## Excel文件工作流程

## CRITICAL：使用公式，而不是硬编码值

**始终使用Excel公式而不是在Python中计算值并硬编码它们。** 这确保了电子表格保持动态和可更新。

### ❌ 错误 - 硬编码计算值
```python
# Bad：在Python中计算并在硬编码结果中
total = df['Sales'].sum()
sheet['B10'] = total  # 硬编码5000

# Bad：在Python中计算增长率
growth = (df.iloc[-1]['Revenue'] - df.iloc[0]['Revenue']) / df.iloc[0]['Revenue']
sheet['C5'] = growth  # 硬编码0.15

# Bad：使用Python计算平均值
avg = sum(values) / len(values)
sheet['D20'] = avg  # 硬编码42.5
```

### ✅ 正确 - 使用Excel公式
```python
# Good：让Excel计算总和
sheet['B10'] = '=SUM(B2:B9)'

# Good：增长率作为Excel公式
sheet['C5'] = '=(C4-C2)/C2'

# Good：使用Excel函数计算平均值
sheet['D20'] = '=AVERAGE(D2:D19)'
```

这适用于所有计算 - 总计、百分比、比率、差异等。电子表格应能够在源数据更改时重新计算。

## 常见工作流程
1. **选择工具**：pandas用于数据，openpyxl用于公式/格式化
2. **创建/加载**：创建新工作簿或加载现有文件
3. **修改**：添加/编辑数据、公式和格式化
4. **保存**：写入文件
5. **重新计算公式（如果使用公式，则强制要求）**：使用recalc.py脚本
   ```bash
   python recalc.py <excel_file> [timeout_seconds]
   ```
   示例：
   ```bash
   python recalc.py output.xlsx 30
   ```
   该脚本：
   - 自动在首次运行时设置LibreOffice宏
   - 在所有工作表中重新计算所有公式
   - 扫描所有单元格以查找Excel错误（#REF!、#DIV/0!等）
   - 返回包含详细错误位置和计数的JSON
   - 在Linux和macOS上均有效

## 公式验证清单

快速检查以确保公式正确：

###  essential Verification
- [ ] **测试2-3个样本引用**：在构建完整模型之前验证它们是否提取正确的值
- [ ] **列映射**：确认Excel列匹配（例如，列64 = BL，不是BK）
- [ ] **行偏移**：记住Excel行是1索引的（DataFrame行5 = Excel行6）

### 常见陷阱
- [ ] **NaN处理**：使用`pd.notna()`检查空值
- [ ] **远端列**：财年数据通常在列50+
- [ ] **多个匹配**：搜索所有发生位置，而不仅仅是第一个
- [ ] **除以零**：在公式中使用`/`之前检查除数（#DIV/0!）
- [ ] **错误的引用**：验证所有单元格引用是否指向预期的单元格（#REF!）
- [ ] **跨工作表引用**：使用正确的格式（Sheet1!A1）进行链接

### 公式测试策略
- [ ] **从小到大**：在广泛应用之前在2-3个单元格上测试公式
- [ ] **验证依赖关系**：检查公式中引用的所有单元格是否存在
- [ ] **测试边缘情况**：包括零、负数和非常大的值

### 解析recalc.py输出
该脚本返回包含错误详细信息的JSON：
```json
{
  "status": "success",           // 或 "errors_found"
  "total_errors": 0,              // 总错误数
  "total_formulas": 42,           // 文件中的公式数
  "error_summary": {              // 如果发现错误，则存在
    "#REF!": {
      "count": 2,
      "locations": ["Sheet1!B5", "Sheet1!C10"]
    }
  }
}
```

## 最佳实践

### 库选择
- **pandas**：最佳用于数据分析、批量操作和简单数据导出
- **openpyxl**：最佳用于复杂格式化、公式和Excel特定功能

### 使用openpyxl
- 单元格索引是1开始的（行=1，列=1指的是单元格A1）
- 使用`data_only=True`读取计算值：`load_workbook('file.xlsx', data_only=True)`
- **警告**：如果以`data_only=True`打开并保存，公式将被值替换并永久丢失
- 对于大型文件：使用`read_only=True`进行读取或`write_only=True`进行写入
- 公式被保留但未评估 - 使用recalc.py更新值

### 使用pandas
- 指定数据类型以避免推断问题：`pd.read_excel('file.xlsx', dtype={'id': str})`
- 对于大型文件，读取特定列：`pd.read_excel('file.xlsx', usecols=['A', 'C', 'E'])`
- 正确处理日期：`pd.read_excel('file.xlsx', parse_dates=['date_column'])`

## 代码风格指南
**IMPORTANT**：当生成用于Excel操作的Python代码时：
- 编写最小化、简洁的Python代码，无需不必要的注释
- 避免冗长的变量名称和重复操作
- 避免不必要的打印语句

**对于Excel文件本身**：
- 在具有复杂公式或重要假设的单元格中添加注释
- 记录硬编码值的来源
- 包含关于关键计算和模型部分的说明