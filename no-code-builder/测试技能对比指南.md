# 测试技能对比指南

本文档详细对比了仓库中三个测试相关技能的区别、使用场景和选择方法。

## 目录

- [技能概览](#技能概览)
- [详细对比](#详细对比)
  - [test-driven-development (TDD)](#1-test-driven-development-tdd)
  - [webapp-testing](#2-webapp-testing)
  - [pypict-claude-skill](#3-pypict-claude-skill-pict-test-designer)
- [如何选择](#如何选择)
- [实际组合使用示例](#实际组合使用示例)
- [总结](#总结)

---

## 技能概览

| 技能名称 | 类型 | 核心功能 | 位置 |
|---------|------|---------|------|
| **test-driven-development** | 开发方法论 | 测试驱动开发流程 | `code-development/test-driven-development/` |
| **webapp-testing** | E2E 测试工具 | 前端浏览器自动化测试 | `code-development/webapp-testing/` |
| **pypict-claude-skill** | 测试设计工具 | 组合测试用例生成 | `code-development/pypict-claude-skill/` |

---

## 详细对比

### 1. test-driven-development (TDD)

#### 核心用途
**测试驱动开发方法论** - 先写测试,再写代码的严格开发流程

#### 特点
- 强制执行 **Red-Green-Refactor** 循环
- 不是测试工具,而是**开发哲学和纪律**
- 适用于任何功能开发或 bug 修复
- 确保测试真正验证行为(必须先看到测试失败)

#### 关键原则
1. **RED**: 写一个失败的测试
2. **GREEN**: 写最小代码让测试通过
3. **REFACTOR**: 清理代码,保持测试通过
4. **铁律**: 没有失败的测试,就不写生产代码

#### 使用场景
- ✅ 开发新功能
- ✅ 修复 bug
- ✅ 重构现有代码
- ✅ 任何需要保证代码质量的场景

#### 典型工作流
```bash
# 1. 写测试 (RED)
npm test path/to/test.test.ts  # 必须失败

# 2. 写代码 (GREEN)
# 写最小代码让测试通过
npm test path/to/test.test.ts  # 必须通过

# 3. 重构 (REFACTOR)
# 改进代码结构,保持测试绿色
npm test  # 所有测试仍然通过
```

#### 红线警告
- ❌ 先写代码再补测试
- ❌ 测试立即通过(说明没测新功能)
- ❌ "我已经手动测过了"
- ❌ "测试太简单不需要"
- ❌ "保留代码作为参考" → **必须删除,从头开始**

---

### 2. webapp-testing

#### 核心用途
**前端 Web 应用的端到端(E2E)测试工具** - 使用 Playwright 进行浏览器自动化

#### 特点
- 基于 **Playwright** 的浏览器自动化
- 测试真实的用户交互(点击、输入、导航、截图)
- 支持静态 HTML 和动态 Web 应用
- 提供服务器生命周期管理工具(`with_server.py`)

#### 使用场景
- ✅ 测试本地运行的 Web 应用
- ✅ 验证前端功能(表单、按钮、导航)
- ✅ 调试 UI 行为
- ✅ 捕获浏览器截图和控制台日志
- ✅ 测试单页应用(SPA)或动态内容
- ✅ 模拟用户操作流程

#### 典型工作流

**方式 1: 使用 with_server.py 管理服务器**
```bash
# 单个服务器
python scripts/with_server.py \
  --server "npm run dev" \
  --port 5173 \
  -- python your_automation.py

# 多个服务器(前后端分离)
python scripts/with_server.py \
  --server "cd backend && python server.py" --port 3000 \
  --server "cd frontend && npm run dev" --port 5173 \
  -- python your_automation.py
```

**方式 2: 编写 Playwright 脚本**
```python
from playwright.sync_api import sync_playwright

with sync_playwright() as p:
    browser = p.chromium.launch(headless=True)
    page = browser.new_page()
    page.goto('http://localhost:5173')

    # 关键: 等待 JS 执行完成
    page.wait_for_load_state('networkidle')

    # 执行测试操作
    page.click('button[type="submit"]')
    page.fill('input[name="email"]', 'test@example.com')
    page.screenshot(path='result.png')

    browser.close()
```

#### 最佳实践
- ✅ 动态页面必须先等待 `networkidle`
- ✅ 使用语义化选择器: `text=`, `role=`, CSS 选择器
- ✅ 先执行 `--help` 查看脚本用法,避免读取源码污染上下文
- ✅ 侦查-然后-行动模式: 先截图/检查 DOM,再执行操作

---

### 3. pypict-claude-skill (PICT Test Designer)

#### 核心用途
**测试用例设计工具** - 使用 PICT(成对组合测试)生成高覆盖率的最小测试集

#### 特点
- 基于**组合测试理论**(Pairwise Testing)
- 自动生成参数组合的最小测试集
- **只设计用例,不执行测试**
- 将数百万种组合减少到几十个关键测试(覆盖率 80-90%)
- 支持约束条件和业务规则

#### 使用场景
- ✅ 有**多个输入参数**的复杂系统
- ✅ 配置测试(操作系统、浏览器、设备组合)
- ✅ API 端点测试(HTTP方法、认证、请求头、负载)
- ✅ Web 表单验证测试
- ✅ 需要系统化设计测试用例的场景
- ✅ 减少穷举测试的数量

#### 典型工作流

**步骤 1: 分析需求,识别参数**
```
需求: 用户登录功能
- 支持用户名/密码登录
- 支持双因素认证(2FA)
- 支持"记住我"功能
- 3次失败后限流
```

**步骤 2: 生成 PICT 模型**
```python
parameters = {
    "Credentials": ["Valid", "Invalid"],
    "TwoFactorAuth": ["Enabled", "Disabled"],
    "RememberMe": ["Checked", "Unchecked"],
    "PreviousFailures": ["0", "1", "2", "3", "4"]
}

constraints = [
    'IF [PreviousFailures] = "3" THEN [Credentials] = "Valid"',
    'IF [TwoFactorAuth] = "Enabled" THEN [Credentials] = "Valid"'
]
```

**步骤 3: 生成测试用例**
```bash
# 使用在线工具
# https://pairwise.yuuniworks.com/

# 或使用 Python 脚本
python scripts/pict_helper.py generate config.json
```

**步骤 4: 输出测试表格**
| Test # | Credentials | TwoFactorAuth | RememberMe | PreviousFailures | Expected Output |
| --- | --- | --- | --- | --- | --- |
| 1 | Valid | Enabled | Checked | 0 | Success, 2FA prompt shown |
| 2 | Invalid | Disabled | Unchecked | 1 | Error: Invalid credentials |
| 3 | Valid | Disabled | Checked | 2 | Success, session saved |
| 4 | Invalid | Disabled | Unchecked | 3 | Error: Account locked |
| ... | ... | ... | ... | ... | ... |

#### 常见模式示例

**Web 表单测试**
```python
parameters = {
    "Name": ["Valid", "Empty", "TooLong"],
    "Email": ["Valid", "Invalid", "Empty"],
    "Password": ["Strong", "Weak", "Empty"],
    "Terms": ["Accepted", "NotAccepted"]
}
```

**API 端点测试**
```python
parameters = {
    "HTTPMethod": ["GET", "POST", "PUT", "DELETE"],
    "Authentication": ["Valid", "Invalid", "Missing"],
    "ContentType": ["JSON", "XML", "FormData"],
    "PayloadSize": ["Empty", "Small", "Large"]
}
```

**配置测试**
```python
parameters = {
    "OS": ["Windows", "Linux", "MacOS"],
    "Browser": ["Chrome", "Firefox", "Safari"],
    "Resolution": ["1920x1080", "1366x768", "Mobile"]
}

constraints = [
    'IF [OS] = "MacOS" THEN [Browser] IN {Safari, Chrome}'
]
```

---

## 如何选择

### 决策树

```
你的需求是什么?
│
├─ 我要开发新功能或修复bug
│  └─> 使用 test-driven-development
│      (先写测试,再写代码)
│
├─ 我要测试 Web 前端的实际功能
│  └─> 使用 webapp-testing
│      (Playwright 浏览器自动化)
│
├─ 我要设计测试用例矩阵
│  └─> 使用 pypict-claude-skill
│      (生成组合测试用例)
│
└─ 我要做完整的测试流程
   └─> 组合使用三者
       1. pypict 设计用例
       2. TDD 驱动开发
       3. webapp-testing 验证 E2E
```

### 场景对照表

| 你想要... | 选择技能 | 说明 |
|---------|---------|------|
| 确保开发过程中的代码质量 | **test-driven-development** | 开发方法论 |
| 自动化测试 Web UI 功能 | **webapp-testing** | 执行工具 |
| 设计全面的测试用例矩阵 | **pypict-claude-skill** | 设计工具 |
| 开发登录功能 | **TDD** | 先写测试,再写代码 |
| 测试登录表单是否正常工作 | **webapp-testing** | 浏览器自动化 |
| 为登录功能设计测试用例 | **pypict-claude-skill** | 参数组合设计 |
| 修复表单验证 bug | **test-driven-development** | 先写失败测试,再修复 |
| 验证多浏览器兼容性 | **webapp-testing** + **pypict** | pypict 设计组合, webapp-testing 执行 |
| 测试 API 端点 | **pypict-claude-skill** | 设计请求参数组合 |
| 验证购物车流程 | **webapp-testing** | 模拟用户操作 |

---

## 实际组合使用示例

### 案例: 开发电商结账页面

假设你要为电商网站开发一个新的结账功能,需求如下:
- 支持 3 种支付方式: 信用卡、PayPal、银行转账
- 支持 3 种配送方式: 标准、快递、隔夜送达
- 支持 3 种用户类型: 访客、注册用户、会员
- 业务规则:
  - 访客不能使用银行转账
  - 会员使用快递免费

#### 步骤 1: 使用 pypict-claude-skill 设计测试用例

```python
# 定义参数
parameters = {
    "PaymentMethod": ["CreditCard", "PayPal", "BankTransfer"],
    "ShippingMethod": ["Standard", "Express", "Overnight"],
    "UserType": ["Guest", "Registered", "Premium"]
}

# 定义约束
constraints = [
    'IF [UserType] = "Guest" THEN [PaymentMethod] <> "BankTransfer"',
    'IF [UserType] = "Premium" AND [ShippingMethod] = "Express" THEN [PaymentMethod] IN {CreditCard, PayPal}'
]
```

生成结果: **12-15 个测试用例**(而不是 3×3×3=27 个穷举用例)

| Test # | Payment | Shipping | UserType | Expected |
|--------|---------|----------|----------|----------|
| 1 | CreditCard | Standard | Guest | Success, standard shipping fee |
| 2 | PayPal | Express | Premium | Success, free express shipping |
| 3 | BankTransfer | Overnight | Registered | Success, overnight fee |
| ... | ... | ... | ... | ... |

#### 步骤 2: 使用 test-driven-development 进行开发

**RED - 写第一个失败的测试**
```typescript
// checkout.test.ts
test('guest cannot use bank transfer', async () => {
  const order = {
    payment: 'BankTransfer',
    shipping: 'Standard',
    userType: 'Guest'
  };

  const result = await processCheckout(order);

  expect(result.error).toBe('Bank transfer not available for guests');
});
```

```bash
# 运行测试 - 必须失败
npm test checkout.test.ts
# ❌ FAIL: processCheckout is not defined
```

**GREEN - 写最小代码通过测试**
```typescript
// checkout.ts
function processCheckout(order) {
  if (order.userType === 'Guest' && order.payment === 'BankTransfer') {
    return { error: 'Bank transfer not available for guests' };
  }
  return { success: true };
}
```

```bash
# 再次运行测试 - 必须通过
npm test checkout.test.ts
# ✅ PASS
```

**REFACTOR - 继续其他测试用例**
```typescript
test('premium users get free express shipping', async () => {
  const order = {
    payment: 'CreditCard',
    shipping: 'Express',
    userType: 'Premium'
  };

  const result = await processCheckout(order);

  expect(result.shippingFee).toBe(0);
});
```

重复 Red-Green-Refactor 循环,完成所有 12-15 个测试用例的开发。

#### 步骤 3: 使用 webapp-testing 验证 E2E 流程

编写 Playwright 脚本验证真实用户流程:

```python
# test_checkout_e2e.py
from playwright.sync_api import sync_playwright

def test_premium_user_checkout():
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True)
        page = browser.new_page()

        # 1. 登录为会员用户
        page.goto('http://localhost:3000/login')
        page.fill('input[name="email"]', 'premium@example.com')
        page.fill('input[name="password"]', 'password123')
        page.click('button[type="submit"]')
        page.wait_for_load_state('networkidle')

        # 2. 添加商品到购物车
        page.goto('http://localhost:3000/products/123')
        page.click('button:has-text("Add to Cart")')

        # 3. 进入结账页面
        page.click('a:has-text("Checkout")')
        page.wait_for_load_state('networkidle')

        # 4. 选择支付和配送
        page.select_option('select[name="payment"]', 'CreditCard')
        page.select_option('select[name="shipping"]', 'Express')

        # 5. 验证免费快递提示
        assert page.locator('text=Free Express Shipping').is_visible()

        # 6. 完成订单
        page.click('button:has-text("Place Order")')
        page.wait_for_selector('text=Order Confirmed')

        # 7. 截图验证
        page.screenshot(path='checkout-success.png')

        browser.close()
```

```bash
# 启动服务器并运行 E2E 测试
python scripts/with_server.py \
  --server "npm run dev" \
  --port 3000 \
  -- python test_checkout_e2e.py
```

#### 步骤 4: 完整验证

现在你已经:
1. ✅ 用 **pypict** 设计了 12-15 个高覆盖率的测试用例
2. ✅ 用 **TDD** 驱动开发,确保每个测试用例都有对应的实现
3. ✅ 用 **webapp-testing** 验证了真实用户流程的 E2E 测试

这种组合使用确保了:
- **设计全面**: 覆盖了所有关键参数组合
- **开发可靠**: TDD 确保每行代码都有测试支撑
- **用户体验**: E2E 测试验证真实交互流程

---

## 总结

### 三句话总结

- **test-driven-development** = 开发方法论(**怎么写代码**)
- **webapp-testing** = E2E 测试工具(**怎么测前端**)
- **pypict-claude-skill** = 测试设计工具(**设计哪些用例**)

### 关系图

```
                      测试全流程
                          │
          ┌───────────────┼───────────────┐
          │               │               │
          ▼               ▼               ▼
    设计测试用例      驱动开发流程      验证用户流程
          │               │               │
   pypict-claude     TDD 方法论      webapp-testing
          │               │               │
     组合测试理论    Red-Green-Refactor   Playwright
          │               │               │
     参数+约束         先测试后代码      浏览器自动化
```

### 它们不是替代关系,而是互补关系

| 阶段 | 使用的技能 | 产出 |
|------|-----------|------|
| **设计阶段** | pypict-claude-skill | 测试用例矩阵 |
| **开发阶段** | test-driven-development | 高质量代码 + 单元测试 |
| **验证阶段** | webapp-testing | E2E 测试脚本 + 截图/日志 |

### 快速参考

**我应该使用哪个技能?**

- 正在写新功能? → **TDD**
- 需要测试用例列表? → **pypict**
- 需要自动化浏览器? → **webapp-testing**
- 需要完整测试流程? → **全部使用**

**记住这些原则**

1. **TDD**: 没有失败的测试,就不写代码
2. **pypict**: 用组合测试减少用例数量,提高覆盖率
3. **webapp-testing**: 等待 `networkidle` 再检查动态内容

---

## 相关文件

- `code-development/test-driven-development/SKILL.md`
- `code-development/webapp-testing/SKILL.md`
- `code-development/pypict-claude-skill/SKILL.md`

---

**文档创建时间**: 2025-12-12
**版本**: 1.0
